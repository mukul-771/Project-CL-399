{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { useTheme } from '@mui/material/styles';\nimport ChartsContinuousGradient from '../internals/components/ChartsAxesGradients/ChartsContinuousGradient';\nimport { useChartId, useDrawingArea } from '../hooks';\nimport { getScale } from '../internals/getScale';\nimport { getPercentageValue } from '../internals/getPercentageValue';\nimport { ChartsText } from '../ChartsText';\nimport { getStringSize } from '../internals/domUtils';\nimport { useAxis } from './useAxis';\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nfunction getPositionOffset(position, legendBox, svgBox) {\n  let offsetX = 0;\n  let offsetY = 0;\n  switch (position.horizontal) {\n    case 'left':\n      offsetX = 0;\n      break;\n    case 'middle':\n      offsetX = (svgBox.width - legendBox.width) / 2;\n      break;\n    case 'right':\n    default:\n      offsetX = svgBox.width - legendBox.width;\n      break;\n  }\n  switch (position.vertical) {\n    case 'top':\n      offsetY = 0;\n      break;\n    case 'middle':\n      offsetY = (svgBox.height - legendBox.height) / 2;\n      break;\n    case 'bottom':\n    default:\n      offsetY = svgBox.height - legendBox.height;\n      break;\n  }\n  return {\n    offsetX,\n    offsetY\n  };\n}\n\n/**\n * Takes placement parameters and element bounding boxes.\n * Returns the x, y coordinates of the elements. And the textAnchor, dominantBaseline for texts.\n */\nfunction getElementPositions(text1Box, barBox, text2Box, params) {\n  if (params.direction === 'column') {\n    const text1 = {\n      y: text1Box.height,\n      dominantBaseline: 'auto'\n    };\n    const text2 = {\n      y: text1Box.height + 2 * params.spacing + barBox.height,\n      dominantBaseline: 'hanging'\n    };\n    const bar = {\n      y: text1Box.height + params.spacing\n    };\n    const totalWidth = Math.max(text1Box.width, barBox.width, text2Box.width);\n    const totalHeight = text1Box.height + barBox.height + text2Box.height + 2 * params.spacing;\n    const boundingBox = {\n      width: totalWidth,\n      height: totalHeight\n    };\n    switch (params.align) {\n      case 'start':\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'start',\n            x: 0\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'start',\n            x: 0\n          }),\n          bar: _extends({}, bar, {\n            x: 0\n          }),\n          boundingBox\n        };\n      case 'end':\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'end',\n            x: totalWidth\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'end',\n            x: totalWidth\n          }),\n          bar: _extends({}, bar, {\n            x: totalWidth - barBox.width\n          }),\n          boundingBox\n        };\n      case 'middle':\n      default:\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'middle',\n            x: totalWidth / 2\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'middle',\n            x: totalWidth / 2\n          }),\n          bar: _extends({}, bar, {\n            x: totalWidth / 2 - barBox.width / 2\n          }),\n          boundingBox\n        };\n    }\n  } else {\n    const text1 = {\n      x: text1Box.width,\n      textAnchor: 'end'\n    };\n    const text2 = {\n      x: text1Box.width + 2 * params.spacing + barBox.width,\n      textAnchor: 'start'\n    };\n    const bar = {\n      x: text1Box.width + params.spacing\n    };\n    const totalHeight = Math.max(text1Box.height, barBox.height, text2Box.height);\n    const totalWidth = text1Box.width + barBox.width + text2Box.width + 2 * params.spacing;\n    const boundingBox = {\n      width: totalWidth,\n      height: totalHeight\n    };\n    switch (params.align) {\n      case 'start':\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'hanging',\n            y: 0\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'hanging',\n            y: 0\n          }),\n          bar: _extends({}, bar, {\n            y: 0\n          }),\n          boundingBox\n        };\n      case 'end':\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'auto',\n            y: totalHeight\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'auto',\n            y: totalHeight\n          }),\n          bar: _extends({}, bar, {\n            y: totalHeight - barBox.height\n          }),\n          boundingBox\n        };\n      case 'middle':\n      default:\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'central',\n            y: totalHeight / 2\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'central',\n            y: totalHeight / 2\n          }),\n          bar: _extends({}, bar, {\n            y: totalHeight / 2 - barBox.height / 2\n          }),\n          boundingBox\n        };\n    }\n  }\n}\nconst defaultLabelFormatter = _ref => {\n  let {\n    formattedValue\n  } = _ref;\n  return formattedValue;\n};\nfunction ContinuousColorLegend(props) {\n  const theme = useTheme();\n  const {\n    id: idProp,\n    minLabel = defaultLabelFormatter,\n    maxLabel = defaultLabelFormatter,\n    scaleType = 'linear',\n    direction,\n    length = '50%',\n    thickness = 5,\n    spacing = 4,\n    align = 'middle',\n    labelStyle = theme.typography.subtitle1,\n    position,\n    axisDirection,\n    axisId\n  } = props;\n  const chartId = useChartId();\n  const id = idProp ?? `gradient-legend-${chartId}`;\n  const isRTL = theme.direction === 'rtl';\n  const axisItem = useAxis({\n    axisDirection,\n    axisId\n  });\n  const {\n    width,\n    height,\n    left,\n    right,\n    top,\n    bottom\n  } = useDrawingArea();\n  const refLength = direction === 'column' ? height + top + bottom : width + left + right;\n  const size = getPercentageValue(length, refLength);\n  const isReversed = direction === 'column';\n  const colorMap = axisItem?.colorMap;\n  if (!colorMap || !colorMap.type || colorMap.type !== 'continuous') {\n    return null;\n  }\n\n  // Define the coordinate to color mapping\n\n  const colorScale = axisItem.colorScale;\n  const minValue = colorMap.min ?? 0;\n  const maxValue = colorMap.max ?? 100;\n  const scale = getScale(scaleType, [minValue, maxValue], isReversed ? [size, 0] : [0, size]);\n\n  // Get texts to display\n\n  const formattedMin = axisItem.valueFormatter?.(minValue, {\n    location: 'legend'\n  }) ?? minValue.toLocaleString();\n  const formattedMax = axisItem.valueFormatter?.(maxValue, {\n    location: 'legend'\n  }) ?? maxValue.toLocaleString();\n  const minText = typeof minLabel === 'string' ? minLabel : minLabel({\n    value: minValue ?? 0,\n    formattedValue: formattedMin\n  });\n  const maxText = typeof maxLabel === 'string' ? maxLabel : maxLabel({\n    value: maxValue ?? 0,\n    formattedValue: formattedMax\n  });\n  const text1 = isReversed ? maxText : minText;\n  const text2 = isReversed ? minText : maxText;\n  const text1Box = getStringSize(text1, _extends({}, labelStyle));\n  const text2Box = getStringSize(text2, _extends({}, labelStyle));\n\n  // Place bar and texts\n\n  const barBox = direction === 'column' || isRTL && direction === 'row' ? {\n    width: thickness,\n    height: size\n  } : {\n    width: size,\n    height: thickness\n  };\n  const legendPositions = getElementPositions(text1Box, barBox, text2Box, {\n    spacing,\n    align,\n    direction\n  });\n  const svgBoundingBox = {\n    width: width + left + right,\n    height: height + top + bottom\n  };\n  const positionOffset = getPositionOffset(_extends({\n    horizontal: 'middle',\n    vertical: 'top'\n  }, position), legendPositions.boundingBox, svgBoundingBox);\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [/*#__PURE__*/_jsx(ChartsContinuousGradient, {\n      isReversed: isReversed,\n      gradientId: id,\n      size: size,\n      direction: direction === 'row' ? 'x' : 'y',\n      scale: scale,\n      colorScale: colorScale,\n      colorMap: colorMap,\n      gradientUnits: \"objectBoundingBox\"\n    }), /*#__PURE__*/_jsx(ChartsText, {\n      text: text1,\n      x: positionOffset.offsetX + legendPositions.text1.x,\n      y: positionOffset.offsetY + legendPositions.text1.y,\n      style: _extends({\n        dominantBaseline: legendPositions.text1.dominantBaseline,\n        textAnchor: legendPositions.text1.textAnchor\n      }, labelStyle)\n    }), /*#__PURE__*/_jsx(\"rect\", _extends({\n      x: positionOffset.offsetX + legendPositions.bar.x,\n      y: positionOffset.offsetY + legendPositions.bar.y\n    }, barBox, {\n      fill: `url(#${id})`\n    })), /*#__PURE__*/_jsx(ChartsText, {\n      text: text2,\n      x: positionOffset.offsetX + legendPositions.text2.x,\n      y: positionOffset.offsetY + legendPositions.text2.y,\n      style: _extends({\n        dominantBaseline: legendPositions.text2.dominantBaseline,\n        textAnchor: legendPositions.text2.textAnchor\n      }, labelStyle)\n    })]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? ContinuousColorLegend.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * The alignment of the texts with the gradient bar.\n   * @default 'middle'\n   */\n  align: PropTypes.oneOf(['end', 'middle', 'start']),\n  /**\n   * The axis direction containing the color configuration to represent.\n   * @default 'z'\n   */\n  axisDirection: PropTypes.oneOf(['x', 'y', 'z']),\n  /**\n   * The id of the axis item with the color configuration to represent.\n   * @default The first axis item.\n   */\n  axisId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The direction of the legend layout.\n   * The default depends on the chart.\n   */\n  direction: PropTypes.oneOf(['column', 'row']),\n  /**\n   * A unique identifier for the gradient.\n   * @default auto-generated id\n   */\n  id: PropTypes.string,\n  /**\n   * The style applied to labels.\n   * @default theme.typography.subtitle1\n   */\n  labelStyle: PropTypes.object,\n  /**\n   * The length of the gradient bar.\n   * Can be a number (in px) or a string with a percentage such as '50%'.\n   * The '100%' is the length of the svg.\n   * @default '50%'\n   */\n  length: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The label to display at the maximum side of the gradient.\n   * Can either be a string, or a function.\n   * If not defined, the formatted maximal value is display.\n   * @default ({ formattedValue }) => formattedValue\n   */\n  maxLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  /**\n   * The label to display at the minimum side of the gradient.\n   * Can either be a string, or a function.\n   * @default ({ formattedValue }) => formattedValue\n   */\n  minLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  /**\n   * The position of the legend.\n   */\n  position: PropTypes.shape({\n    horizontal: PropTypes.oneOf(['left', 'middle', 'right']).isRequired,\n    vertical: PropTypes.oneOf(['bottom', 'middle', 'top']).isRequired\n  }),\n  /**\n   * The scale used to display gradient colors.\n   * @default 'linear'\n   */\n  scaleType: PropTypes.oneOf(['linear', 'log', 'pow', 'sqrt', 'time', 'utc']),\n  /**\n   * The space between the gradient bar and the labels.\n   * @default 4\n   */\n  spacing: PropTypes.number,\n  /**\n   * The thickness of the gradient bar.\n   * @default 5\n   */\n  thickness: PropTypes.number\n} : void 0;\nexport { ContinuousColorLegend };","map":{"version":3,"names":["_extends","React","PropTypes","useTheme","ChartsContinuousGradient","useChartId","useDrawingArea","getScale","getPercentageValue","ChartsText","getStringSize","useAxis","jsx","_jsx","jsxs","_jsxs","getPositionOffset","position","legendBox","svgBox","offsetX","offsetY","horizontal","width","vertical","height","getElementPositions","text1Box","barBox","text2Box","params","direction","text1","y","dominantBaseline","text2","spacing","bar","totalWidth","Math","max","totalHeight","boundingBox","align","textAnchor","x","defaultLabelFormatter","_ref","formattedValue","ContinuousColorLegend","props","theme","id","idProp","minLabel","maxLabel","scaleType","length","thickness","labelStyle","typography","subtitle1","axisDirection","axisId","chartId","isRTL","axisItem","left","right","top","bottom","refLength","size","isReversed","colorMap","type","colorScale","minValue","min","maxValue","scale","formattedMin","valueFormatter","location","toLocaleString","formattedMax","minText","value","maxText","legendPositions","svgBoundingBox","positionOffset","Fragment","children","gradientId","gradientUnits","text","style","fill","process","env","NODE_ENV","propTypes","oneOf","oneOfType","number","string","object","func","shape","isRequired"],"sources":["/Users/mukul7711/Documents/webdev/course/react/my-app/node_modules/@mui/x-charts/esm/ChartsLegend/ContinuousColorLegend.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { useTheme } from '@mui/material/styles';\nimport ChartsContinuousGradient from '../internals/components/ChartsAxesGradients/ChartsContinuousGradient';\nimport { useChartId, useDrawingArea } from '../hooks';\nimport { getScale } from '../internals/getScale';\nimport { getPercentageValue } from '../internals/getPercentageValue';\nimport { ChartsText } from '../ChartsText';\nimport { getStringSize } from '../internals/domUtils';\nimport { useAxis } from './useAxis';\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nfunction getPositionOffset(position, legendBox, svgBox) {\n  let offsetX = 0;\n  let offsetY = 0;\n  switch (position.horizontal) {\n    case 'left':\n      offsetX = 0;\n      break;\n    case 'middle':\n      offsetX = (svgBox.width - legendBox.width) / 2;\n      break;\n    case 'right':\n    default:\n      offsetX = svgBox.width - legendBox.width;\n      break;\n  }\n  switch (position.vertical) {\n    case 'top':\n      offsetY = 0;\n      break;\n    case 'middle':\n      offsetY = (svgBox.height - legendBox.height) / 2;\n      break;\n    case 'bottom':\n    default:\n      offsetY = svgBox.height - legendBox.height;\n      break;\n  }\n  return {\n    offsetX,\n    offsetY\n  };\n}\n\n/**\n * Takes placement parameters and element bounding boxes.\n * Returns the x, y coordinates of the elements. And the textAnchor, dominantBaseline for texts.\n */\nfunction getElementPositions(text1Box, barBox, text2Box, params) {\n  if (params.direction === 'column') {\n    const text1 = {\n      y: text1Box.height,\n      dominantBaseline: 'auto'\n    };\n    const text2 = {\n      y: text1Box.height + 2 * params.spacing + barBox.height,\n      dominantBaseline: 'hanging'\n    };\n    const bar = {\n      y: text1Box.height + params.spacing\n    };\n    const totalWidth = Math.max(text1Box.width, barBox.width, text2Box.width);\n    const totalHeight = text1Box.height + barBox.height + text2Box.height + 2 * params.spacing;\n    const boundingBox = {\n      width: totalWidth,\n      height: totalHeight\n    };\n    switch (params.align) {\n      case 'start':\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'start',\n            x: 0\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'start',\n            x: 0\n          }),\n          bar: _extends({}, bar, {\n            x: 0\n          }),\n          boundingBox\n        };\n      case 'end':\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'end',\n            x: totalWidth\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'end',\n            x: totalWidth\n          }),\n          bar: _extends({}, bar, {\n            x: totalWidth - barBox.width\n          }),\n          boundingBox\n        };\n      case 'middle':\n      default:\n        return {\n          text1: _extends({}, text1, {\n            textAnchor: 'middle',\n            x: totalWidth / 2\n          }),\n          text2: _extends({}, text2, {\n            textAnchor: 'middle',\n            x: totalWidth / 2\n          }),\n          bar: _extends({}, bar, {\n            x: totalWidth / 2 - barBox.width / 2\n          }),\n          boundingBox\n        };\n    }\n  } else {\n    const text1 = {\n      x: text1Box.width,\n      textAnchor: 'end'\n    };\n    const text2 = {\n      x: text1Box.width + 2 * params.spacing + barBox.width,\n      textAnchor: 'start'\n    };\n    const bar = {\n      x: text1Box.width + params.spacing\n    };\n    const totalHeight = Math.max(text1Box.height, barBox.height, text2Box.height);\n    const totalWidth = text1Box.width + barBox.width + text2Box.width + 2 * params.spacing;\n    const boundingBox = {\n      width: totalWidth,\n      height: totalHeight\n    };\n    switch (params.align) {\n      case 'start':\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'hanging',\n            y: 0\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'hanging',\n            y: 0\n          }),\n          bar: _extends({}, bar, {\n            y: 0\n          }),\n          boundingBox\n        };\n      case 'end':\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'auto',\n            y: totalHeight\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'auto',\n            y: totalHeight\n          }),\n          bar: _extends({}, bar, {\n            y: totalHeight - barBox.height\n          }),\n          boundingBox\n        };\n      case 'middle':\n      default:\n        return {\n          text1: _extends({}, text1, {\n            dominantBaseline: 'central',\n            y: totalHeight / 2\n          }),\n          text2: _extends({}, text2, {\n            dominantBaseline: 'central',\n            y: totalHeight / 2\n          }),\n          bar: _extends({}, bar, {\n            y: totalHeight / 2 - barBox.height / 2\n          }),\n          boundingBox\n        };\n    }\n  }\n}\nconst defaultLabelFormatter = ({\n  formattedValue\n}) => formattedValue;\nfunction ContinuousColorLegend(props) {\n  const theme = useTheme();\n  const {\n    id: idProp,\n    minLabel = defaultLabelFormatter,\n    maxLabel = defaultLabelFormatter,\n    scaleType = 'linear',\n    direction,\n    length = '50%',\n    thickness = 5,\n    spacing = 4,\n    align = 'middle',\n    labelStyle = theme.typography.subtitle1,\n    position,\n    axisDirection,\n    axisId\n  } = props;\n  const chartId = useChartId();\n  const id = idProp ?? `gradient-legend-${chartId}`;\n  const isRTL = theme.direction === 'rtl';\n  const axisItem = useAxis({\n    axisDirection,\n    axisId\n  });\n  const {\n    width,\n    height,\n    left,\n    right,\n    top,\n    bottom\n  } = useDrawingArea();\n  const refLength = direction === 'column' ? height + top + bottom : width + left + right;\n  const size = getPercentageValue(length, refLength);\n  const isReversed = direction === 'column';\n  const colorMap = axisItem?.colorMap;\n  if (!colorMap || !colorMap.type || colorMap.type !== 'continuous') {\n    return null;\n  }\n\n  // Define the coordinate to color mapping\n\n  const colorScale = axisItem.colorScale;\n  const minValue = colorMap.min ?? 0;\n  const maxValue = colorMap.max ?? 100;\n  const scale = getScale(scaleType, [minValue, maxValue], isReversed ? [size, 0] : [0, size]);\n\n  // Get texts to display\n\n  const formattedMin = axisItem.valueFormatter?.(minValue, {\n    location: 'legend'\n  }) ?? minValue.toLocaleString();\n  const formattedMax = axisItem.valueFormatter?.(maxValue, {\n    location: 'legend'\n  }) ?? maxValue.toLocaleString();\n  const minText = typeof minLabel === 'string' ? minLabel : minLabel({\n    value: minValue ?? 0,\n    formattedValue: formattedMin\n  });\n  const maxText = typeof maxLabel === 'string' ? maxLabel : maxLabel({\n    value: maxValue ?? 0,\n    formattedValue: formattedMax\n  });\n  const text1 = isReversed ? maxText : minText;\n  const text2 = isReversed ? minText : maxText;\n  const text1Box = getStringSize(text1, _extends({}, labelStyle));\n  const text2Box = getStringSize(text2, _extends({}, labelStyle));\n\n  // Place bar and texts\n\n  const barBox = direction === 'column' || isRTL && direction === 'row' ? {\n    width: thickness,\n    height: size\n  } : {\n    width: size,\n    height: thickness\n  };\n  const legendPositions = getElementPositions(text1Box, barBox, text2Box, {\n    spacing,\n    align,\n    direction\n  });\n  const svgBoundingBox = {\n    width: width + left + right,\n    height: height + top + bottom\n  };\n  const positionOffset = getPositionOffset(_extends({\n    horizontal: 'middle',\n    vertical: 'top'\n  }, position), legendPositions.boundingBox, svgBoundingBox);\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [/*#__PURE__*/_jsx(ChartsContinuousGradient, {\n      isReversed: isReversed,\n      gradientId: id,\n      size: size,\n      direction: direction === 'row' ? 'x' : 'y',\n      scale: scale,\n      colorScale: colorScale,\n      colorMap: colorMap,\n      gradientUnits: \"objectBoundingBox\"\n    }), /*#__PURE__*/_jsx(ChartsText, {\n      text: text1,\n      x: positionOffset.offsetX + legendPositions.text1.x,\n      y: positionOffset.offsetY + legendPositions.text1.y,\n      style: _extends({\n        dominantBaseline: legendPositions.text1.dominantBaseline,\n        textAnchor: legendPositions.text1.textAnchor\n      }, labelStyle)\n    }), /*#__PURE__*/_jsx(\"rect\", _extends({\n      x: positionOffset.offsetX + legendPositions.bar.x,\n      y: positionOffset.offsetY + legendPositions.bar.y\n    }, barBox, {\n      fill: `url(#${id})`\n    })), /*#__PURE__*/_jsx(ChartsText, {\n      text: text2,\n      x: positionOffset.offsetX + legendPositions.text2.x,\n      y: positionOffset.offsetY + legendPositions.text2.y,\n      style: _extends({\n        dominantBaseline: legendPositions.text2.dominantBaseline,\n        textAnchor: legendPositions.text2.textAnchor\n      }, labelStyle)\n    })]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? ContinuousColorLegend.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * The alignment of the texts with the gradient bar.\n   * @default 'middle'\n   */\n  align: PropTypes.oneOf(['end', 'middle', 'start']),\n  /**\n   * The axis direction containing the color configuration to represent.\n   * @default 'z'\n   */\n  axisDirection: PropTypes.oneOf(['x', 'y', 'z']),\n  /**\n   * The id of the axis item with the color configuration to represent.\n   * @default The first axis item.\n   */\n  axisId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The direction of the legend layout.\n   * The default depends on the chart.\n   */\n  direction: PropTypes.oneOf(['column', 'row']),\n  /**\n   * A unique identifier for the gradient.\n   * @default auto-generated id\n   */\n  id: PropTypes.string,\n  /**\n   * The style applied to labels.\n   * @default theme.typography.subtitle1\n   */\n  labelStyle: PropTypes.object,\n  /**\n   * The length of the gradient bar.\n   * Can be a number (in px) or a string with a percentage such as '50%'.\n   * The '100%' is the length of the svg.\n   * @default '50%'\n   */\n  length: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  /**\n   * The label to display at the maximum side of the gradient.\n   * Can either be a string, or a function.\n   * If not defined, the formatted maximal value is display.\n   * @default ({ formattedValue }) => formattedValue\n   */\n  maxLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  /**\n   * The label to display at the minimum side of the gradient.\n   * Can either be a string, or a function.\n   * @default ({ formattedValue }) => formattedValue\n   */\n  minLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  /**\n   * The position of the legend.\n   */\n  position: PropTypes.shape({\n    horizontal: PropTypes.oneOf(['left', 'middle', 'right']).isRequired,\n    vertical: PropTypes.oneOf(['bottom', 'middle', 'top']).isRequired\n  }),\n  /**\n   * The scale used to display gradient colors.\n   * @default 'linear'\n   */\n  scaleType: PropTypes.oneOf(['linear', 'log', 'pow', 'sqrt', 'time', 'utc']),\n  /**\n   * The space between the gradient bar and the labels.\n   * @default 4\n   */\n  spacing: PropTypes.number,\n  /**\n   * The thickness of the gradient bar.\n   * @default 5\n   */\n  thickness: PropTypes.number\n} : void 0;\nexport { ContinuousColorLegend };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}